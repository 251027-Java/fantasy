ci := env('CI', 'false')
maven_ci_args := if ci == 'true' { ' -B' } else { '' }
maven := './mvnw' + maven_ci_args
jar_loc := 'target/fantasy-0.0.1.jar'
debug_args := '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005'
ddl_file := 'scripts/schema.sql'
package_name := 'dev.revature.fantasy'

# database related

db_container := 'fantasy-db'
db_username := 'postgres'
db_password := 'secret'
db_name_dev := 'dev'
db_name_prod := 'prod'

alias refresh := compile

# style check
[group('style')]
check:
    {{ maven }} spotless:check
    {{ maven }} checkstyle:check

# format all code
[group('style')]
format:
    {{ maven }} spotless:apply

# removes artifacts and temporary files
clean:
    {{ maven }} clean

# verify project integrity
verify:
    {{ maven }} verify

# builds the jar
build: clean
    {{ maven }} package -DskipTests

# cleans and verifies project integrity
[default]
default: clean verify

# launch the application
[group('run')]
run: clean
    {{ maven }} spring-boot:run

# launch the application with production configuration
[group('run')]
prod: clean
    {{ maven }} spring-boot:run -Dspring-boot.run.profiles=prod

# launch the jar
[group('run')]
runj:
    java -jar {{ jar_loc }}

# launch the application with the debugger
[group('run')]
debug: clean
    {{ maven }} spring-boot:run -Dspring-boot.run.jvmArguments="{{ debug_args }}"

# compile the program and trigger hot reload
[group('run')]
compile:
    {{ maven }} compile

# create a container with empty databases
[group('db')]
db-create-empty:
    docker run --name {{ db_container }} -e POSTGRES_USER={{ db_username }} -e POSTGRES_PASSWORD={{ db_password }} -p 5432:5432 -d postgres
    @sleep 2
    docker exec {{ db_container }} psql -U {{ db_username }} -v ON_ERROR_STOP=1 -q -c "CREATE DATABASE {{ db_name_prod }}"
    docker exec {{ db_container }} psql -U {{ db_username }} -v ON_ERROR_STOP=1 -q -c "CREATE DATABASE {{ db_name_dev }}"

# create the container and set up the prod database with defined tables
[group('db')]
db-create: db-create-empty (db-import db_name_prod ddl_file)

# destroy the database container
[group('db')]
db-destroy:
    docker rm -f {{ db_container }}

# start the database container
[group('db')]
db-start:
    docker start {{ db_container }}

# stop the database container
[group('db')]
db-stop:
    docker stop {{ db_container }}

# import data into a database
[group('db')]
db-import dbname filepath:
    docker cp {{ filepath }} {{ db_container }}:/tmp/dbdata
    @sleep 2
    docker exec {{ db_container }} psql -U {{ db_username }} -d {{ dbname }} -v ON_ERROR_STOP=1 -q -f tmp/dbdata

# export a database
[group('db')]
db-export dbname:
    docker exec {{ db_container }} pg_dump -U {{ db_username }} -F p {{ dbname }} > {{ dbname }}.data

# runs tests and generates coverage
[group('test')]
test:
    {{ maven }} test

# view coverage
[group('test')]
coverage cmd='start':
    {{ cmd }} "target/site/jacoco/index.html"

# generate a DDL script from JPA entities
[group('db')]
ddl filepath=ddl_file:
    {{ maven }} test-compile
    {{ maven }} exec:java -Dexec.mainClass="scripts.GenerateDdl" -Dexec.classpathScope=test -Dexec.args="{{ package_name }} {{ filepath }}"

# output the OpenApi specification of the current running program
api:
    curl http://localhost:8080/v3/api-docs | node -p "JSON.stringify(JSON.parse(require('fs').readFileSync(0, 'utf-8')), null, 2)" > openapi.json
